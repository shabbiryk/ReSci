{"ast":null,"code":"import { BigNumber, providers, utils } from 'ethers';\nimport { hashSync } from 'bcryptjs';\nimport { PrivateKey } from '@textile/hub';\n\nconst generateMessageForEntropy = (ethereum_address, application_name) => {\n  return 'The Ethereum address used by this application is: \\n' + '\\n' + ethereum_address;\n};\n\nconst getSigner = async () => {\n  if (!window.ethereum) {\n    throw new Error('Ethereum is not connected. Please download Metamask from https://metamask.io/download.html');\n  }\n\n  console.debug('Initializing web3 provider...');\n  const provider = new providers.Web3Provider(window.ethereum);\n  const signer = provider.getSigner();\n  return signer;\n};\n\nexport const getProvider = async () => {\n  if (!window.ethereum) {\n    throw new Error('Ethereum is not connected. Please download Metamask from https://metamask.io/download.html');\n  }\n\n  console.debug('Initializing web3 provider...');\n  window.ethereum.enable();\n  const provider = new providers.Web3Provider(window.ethereum);\n  return provider;\n};\n\nconst getAddressAndSigner = async () => {\n  const signer = await getSigner(); // @ts-ignore\n\n  const accounts = await window.ethereum.request({\n    method: 'eth_requestAccounts'\n  });\n\n  if (accounts.length === 0) {\n    throw new Error('No account is provided. Please provide an account to this application.');\n  }\n\n  const address = accounts[0];\n  return {\n    address,\n    signer\n  };\n};\n\nexport const generateSignature = async () => {\n  const metamask = await getAddressAndSigner(); // avoid sending the raw secret by hashing it first\n\n  const secret = hashSync(\"Password\", 10);\n  const message = generateMessageForEntropy(metamask.address, 'cermaic demo');\n  const signedText = await metamask.signer.signMessage(message);\n  const hash = utils.keccak256(signedText);\n  const seed = hash // @ts-ignore\n  .replace('0x', '') // @ts-ignore\n  .match(/.{2}/g).map(hexNoPrefix => BigNumber.from('0x' + hexNoPrefix).toNumber());\n  return {\n    seed,\n    metamask\n  };\n};\nexport const getMetamaskIdentity = async () => {\n  const metamask = await getAddressAndSigner(); // avoid sending the raw secret by hashing it first\n\n  const secret = hashSync(\"Password\", 10);\n  const message = generateMessageForEntropy(metamask.address, 'cermaic demo');\n  const signedText = await metamask.signer.signMessage(message);\n  const hash = utils.keccak256(signedText);\n  const array = hash // @ts-ignore\n  .replace('0x', '') // @ts-ignore\n  .match(/.{2}/g).map(hexNoPrefix => BigNumber.from('0x' + hexNoPrefix).toNumber());\n\n  if (array.length !== 32) {\n    throw new Error('Hash of signature is not the correct size! Something went wrong!');\n  }\n\n  const identity = PrivateKey.fromRawEd25519Seed(Uint8Array.from(array));\n  console.log(identity.toString()); // Your app can now use this identity for generating a user Mailbox, Threads, Buckets, etc\n\n  return identity;\n};","map":{"version":3,"sources":["C:/Users/shabb/Project/Resci/lib/signerconnect.js"],"names":["BigNumber","providers","utils","hashSync","PrivateKey","generateMessageForEntropy","ethereum_address","application_name","getSigner","window","ethereum","Error","console","debug","provider","Web3Provider","signer","getProvider","enable","getAddressAndSigner","accounts","request","method","length","address","generateSignature","metamask","secret","message","signedText","signMessage","hash","keccak256","seed","replace","match","map","hexNoPrefix","from","toNumber","getMetamaskIdentity","array","identity","fromRawEd25519Seed","Uint8Array","log","toString"],"mappings":"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","sourcesContent":["import { BigNumber, providers, utils } from 'ethers'\nimport { hashSync } from 'bcryptjs'\nimport { PrivateKey } from '@textile/hub'\n\nconst generateMessageForEntropy = (ethereum_address, application_name) => {\n    return (\n      'The Ethereum address used by this application is: \\n' +\n      '\\n' +\n      ethereum_address\n    );\n}\n\nconst getSigner = async () => {\n    if (!window.ethereum) {\n        throw new Error(\n            'Ethereum is not connected. Please download Metamask from https://metamask.io/download.html'\n        );\n    }\n\n    console.debug('Initializing web3 provider...');\n    const provider = new providers.Web3Provider(window.ethereum);\n    const signer = provider.getSigner();\n    return signer\n}\n\nexport const getProvider = async () => {\n    if (!window.ethereum) {\n        throw new Error(\n            'Ethereum is not connected. Please download Metamask from https://metamask.io/download.html'\n        );\n    }\n\n    console.debug('Initializing web3 provider...');\n    window.ethereum.enable()\n    const provider = new providers.Web3Provider(window.ethereum);\n    return provider\n}\n\nconst getAddressAndSigner = async() => {\n    const signer = await getSigner()\n    // @ts-ignore\n    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });\n    if (accounts.length === 0) {\n        throw new Error('No account is provided. Please provide an account to this application.');\n    }\n    const address = accounts[0];\n    return {address, signer}\n}\n\nexport const generateSignature = async () => {\n    const metamask = await getAddressAndSigner()\n    // avoid sending the raw secret by hashing it first\n    const secret = hashSync(\"Password\", 10)\n    const message = generateMessageForEntropy(metamask.address, 'cermaic demo')\n    const signedText = await metamask.signer.signMessage(message);\n    const hash = utils.keccak256(signedText);\n    const seed = hash\n        // @ts-ignore\n        .replace('0x', '')\n        // @ts-ignore\n        .match(/.{2}/g)\n        .map((hexNoPrefix) => BigNumber.from('0x' + hexNoPrefix).toNumber())\n    return {seed, metamask}\n}\n\nexport const getMetamaskIdentity = async () => {\n    const metamask = await getAddressAndSigner()\n    // avoid sending the raw secret by hashing it first\n    const secret = hashSync(\"Password\", 10)\n    const message = generateMessageForEntropy(metamask.address, 'cermaic demo')\n    const signedText = await metamask.signer.signMessage(message);\n    const hash = utils.keccak256(signedText);\n    const array = hash\n        // @ts-ignore\n        .replace('0x', '')\n        // @ts-ignore\n        .match(/.{2}/g)\n        .map((hexNoPrefix) => BigNumber.from('0x' + hexNoPrefix).toNumber())\n\n    if (array.length !== 32) {\n        throw new Error('Hash of signature is not the correct size! Something went wrong!');\n    }\n    const identity = PrivateKey.fromRawEd25519Seed(Uint8Array.from(array))\n    console.log(identity.toString())\n\n    // Your app can now use this identity for generating a user Mailbox, Threads, Buckets, etc\n    return identity\n  }\n"]},"metadata":{},"sourceType":"module"}